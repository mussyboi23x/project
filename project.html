<!DOCTYPE html>
<html>
<head>
  <title>Buckshot Roulette 3D (Simplified)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222;
    }
    #game-canvas {
      width: 100vw;
      height: 100vh;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('webgl');

    // WebGL setup (very basic)
    if (!ctx) {
      alert('WebGL not supported!');
    }

    // Vertex shader (basic)
    const vertexShaderSource = `
      attribute vec4 aVertexPosition;

      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      }
    `;

    // Fragment shader (basic)
    const fragmentShaderSource = `
      void main() {
        gl_FragColor = vec4(0.8, 0.8, 0.8, 1.0); // Simple grey color
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vertexShader = createShader(ctx, ctx.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(ctx, ctx.FRAGMENT_SHADER, fragmentShaderSource);

    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    if (!ctx.getProgramParameter(shaderProgram, ctx.LINK_STATUS)) {
      alert('Unable to initialize the shader program: ' + ctx.getProgramInfoLog(shaderProgram));
    }

    ctx.useProgram(shaderProgram);

    // Vertex data (simple cube for example)
    const positions = [
      // Front face
      -1.0, -1.0, 1.0,
      1.0, -1.0, 1.0,
      1.0, 1.0, 1.0,
      -1.0, 1.0, 1.0,

      // Back face
      -1.0, -1.0, -1.0,
      -1.0, 1.0, -1.0,
      1.0, 1.0, -1.0,
      1.0, -1.0, -1.0,

      // Top face
      -1.0, 1.0, -1.0,
      -1.0, 1.0, 1.0,
      1.0, 1.0, 1.0,
      1.0, 1.0, -1.0,

      // Bottom face
      -1.0, -1.0, -1.0,
      1.0, -1.0, -1.0,
      1.0, -1.0, 1.0,
      -1.0, -1.0, 1.0,

      // Right face
      1.0, -1.0, -1.0,
      1.0, 1.0, -1.0,
      1.0, 1.0, 1.0,
      1.0, -1.0, 1.0,

      // Left face
      -1.0, -1.0, -1.0,
      -1.0, -1.0, 1.0,
      -1.0, 1.0, 1.0,
      -1.0, 1.0, -1.0,
    ];

    const positionBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, positionBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array(positions), ctx.STATIC_DRAW);

    const positionAttributeLocation = ctx.getAttribLocation(shaderProgram, 'aVertexPosition');
    ctx.enableVertexAttribArray(positionAttributeLocation);
    ctx.vertexAttribPointer(positionAttributeLocation, 3, ctx.FLOAT, false, 0, 0);

    const indices = [
      0, 1, 2, 0, 2, 3, // Front
      4, 5, 6, 4, 6, 7, // Back
      8, 9, 10, 8, 10, 11, // Top
      12, 13, 14, 12, 14, 15, // Bottom
      16, 17, 18, 16, 18, 19, // Right
      20, 21, 22, 20, 22, 23, // Left
    ];

    const indexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, indexBuffer);
    ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), ctx.STATIC_DRAW);

    // Matrix setup (very basic)
    const projectionMatrix = mat4.create();
    mat4.perspective(projectionMatrix, Math.PI / 4, canvas.clientWidth / canvas.clientHeight, 0.1, 100.0);

    const modelViewMatrix = mat4.create();
    mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -6.0]);
    mat4.rotateX(modelViewMatrix, modelViewMatrix, 0.5);
    mat4.rotateY(modelViewMatrix, modelViewMatrix, 0.5);

    const projectionMatrixLocation = ctx.getUniformLocation(shaderProgram, 'uProjectionMatrix');
    const modelViewMatrixLocation = ctx.getUniformLocation(shaderProgram, 'uModelViewMatrix');

    ctx.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
    ctx.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

    // Draw
    ctx.clearColor(0.0, 0.0, 0.0, 1.0);
    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT);
    ctx.enable(ctx.DEPTH_TEST);
    ctx.drawElements(ctx.TRIANGLES, indices.length, ctx.UNSIGNED_SHORT, 0);

    // Simple matrix library (you'd normally use a full library like gl-matrix)
    function mat4() {
      return {
        create: function() {
          return new Float32Array(16);
        },
        perspective: function(out, fovy, aspect, near, far) {
          // ... (Simplified perspective matrix calculation)
          out[0] = 1 / (aspect * Math.tan(fovy / 2));
          out[5] = 1 / Math.tan(fovy / 2);
          out[10] = -(far + near) / (far - near);
          out[11] = -1;
          out[14] = -(2 * far * near) / (far - near);
          return out;
        },
        translate: function(out, a, v) {
          // ... (Simplified translate matrix calculation)
          out[12] = a[0] + v[0];
          out[13] = a[5] + v[1];
          out[14] = a[10] + v[2];
          return out;
        },
        rotateX: function(out, a, rad) {
          // ... (Simplified rotateX matrix calculation)
          const s = Math.sin(rad), c = Math.cos(rad);
          out[5] = a[5] * c + a[9] * -s;
          out[6] = a[6] * c + a[10] * -s;
          out[9] = a[5] * s + a[9] * c;
          out[10] = a
